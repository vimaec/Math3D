// AUTOGENERATED FILE: Do not edit directly, instead edit MathOps.tt

// MIT License 
// Copyright (C) 2019 Ara 3D. Inc
// https://ara3d.com
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

using System;
using System.Runtime.CompilerServices;

namespace Ara3D 
{
	public static partial class MathOps 
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Abs(this double x) => Math.Abs(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Acos(this double x) => Math.Acos(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Asin(this double x) => Math.Asin(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Atan(this double x) => Math.Atan(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cos(this double x) => Math.Cos(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cosh(this double x) => Math.Cosh(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Exp(this double x) => Math.Exp(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Log(this double x) => Math.Log(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Log10(this double x) => Math.Log10(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sin(this double x) => Math.Sin(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sinh(this double x) => Math.Sinh(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sqrt(this double x) => Math.Sqrt(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Tan(this double x) => Math.Tan(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Tanh(this double x) => Math.Tanh(x);

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Abs(this float x) => (float)Math.Abs(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Acos(this float x) => (float)Math.Acos(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Asin(this float x) => (float)Math.Asin(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Atan(this float x) => (float)Math.Atan(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cos(this float x) => (float)Math.Cos(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cosh(this float x) => (float)Math.Cosh(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Exp(this float x) => (float)Math.Exp(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Log(this float x) => (float)Math.Log(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Log10(this float x) => (float)Math.Log10(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sin(this float x) => (float)Math.Sin(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sinh(this float x) => (float)Math.Sinh(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sqrt(this float x) => (float)Math.Sqrt(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Tan(this float x) => (float)Math.Tan(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Tanh(this float x) => (float)Math.Tanh(x);

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Inverse (this float x) => (float)1 / x; 		
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Truncate (this float x) => (float)Math.Truncate(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Ceiling (this float x) => (float)Math.Ceiling(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Floor (this float x) => (float)Math.Floor(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Round (this float x) => (float)System.Math.Round(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ToRadians(this float x) => (float)(x * Constants.DegreesToRadians);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ToDegrees(this float x) => (float)(x * Constants.RadiansToDegrees);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this float v1, float v2) => (v1 - v2).Abs();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity(this float v) => float.IsInfinity(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN(this float v) => float.IsNaN(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostEquals(this float v1, float v2) => (v2 - v1).AlmostZero();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostZero(this float v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Inverse (this double x) => (double)1 / x; 		
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Truncate (this double x) => (double)Math.Truncate(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Ceiling (this double x) => (double)Math.Ceiling(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Floor (this double x) => (double)Math.Floor(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Round (this double x) => (double)System.Math.Round(x); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ToRadians(this double x) => (double)(x * Constants.DegreesToRadians);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ToDegrees(this double x) => (double)(x * Constants.RadiansToDegrees);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this double v1, double v2) => (v1 - v2).Abs();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity(this double v) => double.IsInfinity(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN(this double v) => double.IsNaN(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostEquals(this double v1, double v2) => (v2 - v1).AlmostZero();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostZero(this double v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Add (this int v1, int v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Subtract (this int v1, int v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Multiply (this int v1, int v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Divide (this int v1, int v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Negate (this int v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Add (this long v1, long v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Subtract (this long v1, long v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Multiply (this long v1, long v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Divide (this long v1, long v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Negate (this long v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Add (this float v1, float v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Subtract (this float v1, float v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Multiply (this float v1, float v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Divide (this float v1, float v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Negate (this float v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Add (this double v1, double v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Subtract (this double v1, double v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Multiply (this double v1, double v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Divide (this double v1, double v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Negate (this double v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Add (this Vector2 v1, Vector2 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Subtract (this Vector2 v1, Vector2 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Multiply (this Vector2 v1, Vector2 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Divide (this Vector2 v1, Vector2 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Negate (this Vector2 v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Add (this Vector3 v1, Vector3 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Subtract (this Vector3 v1, Vector3 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Multiply (this Vector3 v1, Vector3 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Divide (this Vector3 v1, Vector3 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Negate (this Vector3 v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Add (this Vector4 v1, Vector4 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Subtract (this Vector4 v1, Vector4 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Multiply (this Vector4 v1, Vector4 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Divide (this Vector4 v1, Vector4 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Negate (this Vector4 v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Add (this DVector2 v1, DVector2 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Subtract (this DVector2 v1, DVector2 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Multiply (this DVector2 v1, DVector2 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Divide (this DVector2 v1, DVector2 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Negate (this DVector2 v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Add (this DVector3 v1, DVector3 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Subtract (this DVector3 v1, DVector3 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Multiply (this DVector3 v1, DVector3 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Divide (this DVector3 v1, DVector3 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Negate (this DVector3 v) => -v; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Add (this DVector4 v1, DVector4 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Subtract (this DVector4 v1, DVector4 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Multiply (this DVector4 v1, DVector4 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Divide (this DVector4 v1, DVector4 v2) => v1 / v2;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Negate (this DVector4 v) => -v; 

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this int v, int min, int max) => v >= min && v < max;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Sqr (this int x) => x * x;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Cube (this int x) => x * x * x; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Min (this int v1, int v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Max (this int v1, int v2) => Math.Max(v1, v2); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this long v, long min, long max) => v >= min && v < max;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Sqr (this long x) => x * x;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Cube (this long x) => x * x * x; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Min (this long v1, long v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Max (this long v1, long v2) => Math.Max(v1, v2); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this float v, float min, float max) => v >= min && v < max;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sqr (this float x) => x * x;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cube (this float x) => x * x * x; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Min (this float v1, float v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Max (this float v1, float v2) => Math.Max(v1, v2); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this double v, double min, double max) => v >= min && v < max;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sqr (this double x) => x * x;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cube (this double x) => x * x * x; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Min (this double v1, double v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Max (this double v1, double v2) => Math.Max(v1, v2); 

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this int v1, int v2) => v1 > v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this int v1, int v2) => v1 < v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this int v1, int v2) => v1 >= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this int v1, int v2) => v1 <= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this int v1, int v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this int v1, int v2) => v1 != v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this long v1, long v2) => v1 > v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this long v1, long v2) => v1 < v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this long v1, long v2) => v1 >= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this long v1, long v2) => v1 <= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this long v1, long v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this long v1, long v2) => v1 != v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this float v1, float v2) => v1 > v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this float v1, float v2) => v1 < v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this float v1, float v2) => v1 >= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this float v1, float v2) => v1 <= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this float v1, float v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this float v1, float v2) => v1 != v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this double v1, double v2) => v1 > v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this double v1, double v2) => v1 < v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this double v1, double v2) => v1 >= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this double v1, double v2) => v1 <= v2; 
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this double v1, double v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this double v1, double v2) => v1 != v2; 

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool And (this bool a, bool b) => a && b; 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Or (this bool a, bool b) => a || b;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NAnd (this bool a, bool b) => !(a && b);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool XOr (this bool a, bool b) => a || b && !(a && b); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NOr (this bool a, bool b) => !(a || b); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Not (this bool a) => !a;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this bool a, bool b) => a == b;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq ( this bool a, bool b) => a != b; 

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int And (this int a, int b) => a & b; 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Or (this int a, int b) => a | b;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int NAnd (this int a, int b) => ~(a & b);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int XOr (this int a, int b) => a | b & ~(a & b);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int NOr (this int a, int b) => ~(a | b); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Not (this int a) => ~a;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Abs (this int a) => Math.Abs(a);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static int DivideRoundUp (this int a, int b) => a / b + (a % b > 0 ? 1 : 0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsEven (this int n) => n % 2 == 0;        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsOdd (this int n) => n % 2 == 1;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsPowerOfTwo (this int v) => v > 0 && (v & (v - 1)) == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN (this int n) => false;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long And (this long a, long b) => a & b; 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Or (this long a, long b) => a | b;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long NAnd (this long a, long b) => ~(a & b);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long XOr (this long a, long b) => a | b & ~(a & b);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long NOr (this long a, long b) => ~(a | b); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Not (this long a) => ~a;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Abs (this long a) => Math.Abs(a);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static long DivideRoundUp (this long a, long b) => a / b + (a % b > 0 ? 1 : 0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsEven (this long n) => n % 2 == 0;        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsOdd (this long n) => n % 2 == 1;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsPowerOfTwo (this long v) => v > 0 && (v & (v - 1)) == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN (this long n) => false;


		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Lerp(this float v1, float v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LerpPrecise(this float v1, float v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ClampLower(this float v, float min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ClampUpper(this float v, float max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Clamp(this float v, float min, float max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Average(this float v1, float v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Barycentric(this float v1, float v2, float v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Lerp(this double v1, double v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LerpPrecise(this double v1, double v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ClampLower(this double v, double min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ClampUpper(this double v, double max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Clamp(this double v, double min, double max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Average(this double v1, double v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Barycentric(this double v1, double v2, double v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Lerp(this Vector2 v1, Vector2 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 LerpPrecise(this Vector2 v1, Vector2 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ClampLower(this Vector2 v, Vector2 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ClampUpper(this Vector2 v, Vector2 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Clamp(this Vector2 v, Vector2 min, Vector2 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Average(this Vector2 v1, Vector2 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Barycentric(this Vector2 v1, Vector2 v2, Vector2 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Lerp(this Vector3 v1, Vector3 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 LerpPrecise(this Vector3 v1, Vector3 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ClampLower(this Vector3 v, Vector3 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ClampUpper(this Vector3 v, Vector3 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Clamp(this Vector3 v, Vector3 min, Vector3 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Average(this Vector3 v1, Vector3 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Barycentric(this Vector3 v1, Vector3 v2, Vector3 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Lerp(this Vector4 v1, Vector4 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 LerpPrecise(this Vector4 v1, Vector4 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ClampLower(this Vector4 v, Vector4 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ClampUpper(this Vector4 v, Vector4 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Clamp(this Vector4 v, Vector4 min, Vector4 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Average(this Vector4 v1, Vector4 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Barycentric(this Vector4 v1, Vector4 v2, Vector4 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Lerp(this DVector2 v1, DVector2 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 LerpPrecise(this DVector2 v1, DVector2 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ClampLower(this DVector2 v, DVector2 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ClampUpper(this DVector2 v, DVector2 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Clamp(this DVector2 v, DVector2 min, DVector2 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Average(this DVector2 v1, DVector2 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Barycentric(this DVector2 v1, DVector2 v2, DVector2 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Lerp(this DVector3 v1, DVector3 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 LerpPrecise(this DVector3 v1, DVector3 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ClampLower(this DVector3 v, DVector3 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ClampUpper(this DVector3 v, DVector3 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Clamp(this DVector3 v, DVector3 min, DVector3 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Average(this DVector3 v1, DVector3 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Barycentric(this DVector3 v1, DVector3 v2, DVector3 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Lerp(this DVector4 v1, DVector4 v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 LerpPrecise(this DVector4 v1, DVector4 v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ClampLower(this DVector4 v, DVector4 min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ClampUpper(this DVector4 v, DVector4 max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Clamp(this DVector4 v, DVector4 min, DVector4 max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Average(this DVector4 v1, DVector4 v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Barycentric(this DVector4 v1, DVector4 v2, DVector4 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector2 v1, Vector2 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector2 v1, Vector2 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector2 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector2 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Normalize(this Vector2 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector2 v1, Vector2 v2) => v1.X * v2.X + v1.Y * v2.Y;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Min(this Vector2 v1, Vector2 v2) => new Vector2(v1.X.Min(v2.X), v1.Y.Min(v2.Y));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Max(this Vector2 v1, Vector2 v2) => new Vector2(v1.X.Max(v2.X), v1.Y.Max(v2.Y));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 SquareRoot (this Vector2 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Abs (this Vector2 v) => new Vector2(v.X.Abs(), v.Y.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Acos (this Vector2 v) => new Vector2(v.X.Acos(), v.Y.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Asin (this Vector2 v) => new Vector2(v.X.Asin(), v.Y.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Atan (this Vector2 v) => new Vector2(v.X.Atan(), v.Y.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cos (this Vector2 v) => new Vector2(v.X.Cos(), v.Y.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cosh (this Vector2 v) => new Vector2(v.X.Cosh(), v.Y.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Exp (this Vector2 v) => new Vector2(v.X.Exp(), v.Y.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Log (this Vector2 v) => new Vector2(v.X.Log(), v.Y.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Log10 (this Vector2 v) => new Vector2(v.X.Log10(), v.Y.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sin (this Vector2 v) => new Vector2(v.X.Sin(), v.Y.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sinh (this Vector2 v) => new Vector2(v.X.Sinh(), v.Y.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sqrt (this Vector2 v) => new Vector2(v.X.Sqrt(), v.Y.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Tan (this Vector2 v) => new Vector2(v.X.Tan(), v.Y.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Tanh (this Vector2 v) => new Vector2(v.X.Tanh(), v.Y.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Inverse (this Vector2 v) => new Vector2(v.X.Inverse(), v.Y.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Ceiling (this Vector2 v) => new Vector2(v.X.Ceiling(), v.Y.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Floor (this Vector2 v) => new Vector2(v.X.Floor(), v.Y.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Round (this Vector2 v) => new Vector2(v.X.Round(), v.Y.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Truncate (this Vector2 v) => new Vector2(v.X.Truncate(), v.Y.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sqr (this Vector2 v) => new Vector2(v.X.Sqr(), v.Y.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cube (this Vector2 v) => new Vector2(v.X.Cube(), v.Y.Cube());

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector3 v1, Vector3 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector3 v1, Vector3 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector3 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector3 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Normalize(this Vector3 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector3 v1, Vector3 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Min(this Vector3 v1, Vector3 v2) => new Vector3(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Max(this Vector3 v1, Vector3 v2) => new Vector3(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 SquareRoot (this Vector3 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Abs (this Vector3 v) => new Vector3(v.X.Abs(), v.Y.Abs(), v.Z.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Acos (this Vector3 v) => new Vector3(v.X.Acos(), v.Y.Acos(), v.Z.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Asin (this Vector3 v) => new Vector3(v.X.Asin(), v.Y.Asin(), v.Z.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Atan (this Vector3 v) => new Vector3(v.X.Atan(), v.Y.Atan(), v.Z.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cos (this Vector3 v) => new Vector3(v.X.Cos(), v.Y.Cos(), v.Z.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cosh (this Vector3 v) => new Vector3(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Exp (this Vector3 v) => new Vector3(v.X.Exp(), v.Y.Exp(), v.Z.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Log (this Vector3 v) => new Vector3(v.X.Log(), v.Y.Log(), v.Z.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Log10 (this Vector3 v) => new Vector3(v.X.Log10(), v.Y.Log10(), v.Z.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sin (this Vector3 v) => new Vector3(v.X.Sin(), v.Y.Sin(), v.Z.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sinh (this Vector3 v) => new Vector3(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sqrt (this Vector3 v) => new Vector3(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Tan (this Vector3 v) => new Vector3(v.X.Tan(), v.Y.Tan(), v.Z.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Tanh (this Vector3 v) => new Vector3(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Inverse (this Vector3 v) => new Vector3(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Ceiling (this Vector3 v) => new Vector3(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Floor (this Vector3 v) => new Vector3(v.X.Floor(), v.Y.Floor(), v.Z.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Round (this Vector3 v) => new Vector3(v.X.Round(), v.Y.Round(), v.Z.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Truncate (this Vector3 v) => new Vector3(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sqr (this Vector3 v) => new Vector3(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cube (this Vector3 v) => new Vector3(v.X.Cube(), v.Y.Cube(), v.Z.Cube());

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector4 v1, Vector4 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector4 v1, Vector4 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector4 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector4 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Normalize(this Vector4 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector4 v1, Vector4 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Min(this Vector4 v1, Vector4 v2) => new Vector4(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z), v1.W.Min(v2.W));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Max(this Vector4 v1, Vector4 v2) => new Vector4(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z), v1.W.Max(v2.W));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 SquareRoot (this Vector4 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Abs (this Vector4 v) => new Vector4(v.X.Abs(), v.Y.Abs(), v.Z.Abs(), v.W.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Acos (this Vector4 v) => new Vector4(v.X.Acos(), v.Y.Acos(), v.Z.Acos(), v.W.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Asin (this Vector4 v) => new Vector4(v.X.Asin(), v.Y.Asin(), v.Z.Asin(), v.W.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Atan (this Vector4 v) => new Vector4(v.X.Atan(), v.Y.Atan(), v.Z.Atan(), v.W.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cos (this Vector4 v) => new Vector4(v.X.Cos(), v.Y.Cos(), v.Z.Cos(), v.W.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cosh (this Vector4 v) => new Vector4(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh(), v.W.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Exp (this Vector4 v) => new Vector4(v.X.Exp(), v.Y.Exp(), v.Z.Exp(), v.W.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Log (this Vector4 v) => new Vector4(v.X.Log(), v.Y.Log(), v.Z.Log(), v.W.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Log10 (this Vector4 v) => new Vector4(v.X.Log10(), v.Y.Log10(), v.Z.Log10(), v.W.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sin (this Vector4 v) => new Vector4(v.X.Sin(), v.Y.Sin(), v.Z.Sin(), v.W.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sinh (this Vector4 v) => new Vector4(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh(), v.W.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sqrt (this Vector4 v) => new Vector4(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt(), v.W.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Tan (this Vector4 v) => new Vector4(v.X.Tan(), v.Y.Tan(), v.Z.Tan(), v.W.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Tanh (this Vector4 v) => new Vector4(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh(), v.W.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Inverse (this Vector4 v) => new Vector4(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse(), v.W.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Ceiling (this Vector4 v) => new Vector4(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling(), v.W.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Floor (this Vector4 v) => new Vector4(v.X.Floor(), v.Y.Floor(), v.Z.Floor(), v.W.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Round (this Vector4 v) => new Vector4(v.X.Round(), v.Y.Round(), v.Z.Round(), v.W.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Truncate (this Vector4 v) => new Vector4(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate(), v.W.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sqr (this Vector4 v) => new Vector4(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr(), v.W.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cube (this Vector4 v) => new Vector4(v.X.Cube(), v.Y.Cube(), v.Z.Cube(), v.W.Cube());

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector2 v1, DVector2 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector2 v1, DVector2 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector2 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector2 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Normalize(this DVector2 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector2 v1, DVector2 v2) => v1.X * v2.X + v1.Y * v2.Y;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Min(this DVector2 v1, DVector2 v2) => new DVector2(v1.X.Min(v2.X), v1.Y.Min(v2.Y));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Max(this DVector2 v1, DVector2 v2) => new DVector2(v1.X.Max(v2.X), v1.Y.Max(v2.Y));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 SquareRoot (this DVector2 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Abs (this DVector2 v) => new DVector2(v.X.Abs(), v.Y.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Acos (this DVector2 v) => new DVector2(v.X.Acos(), v.Y.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Asin (this DVector2 v) => new DVector2(v.X.Asin(), v.Y.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Atan (this DVector2 v) => new DVector2(v.X.Atan(), v.Y.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cos (this DVector2 v) => new DVector2(v.X.Cos(), v.Y.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cosh (this DVector2 v) => new DVector2(v.X.Cosh(), v.Y.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Exp (this DVector2 v) => new DVector2(v.X.Exp(), v.Y.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Log (this DVector2 v) => new DVector2(v.X.Log(), v.Y.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Log10 (this DVector2 v) => new DVector2(v.X.Log10(), v.Y.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sin (this DVector2 v) => new DVector2(v.X.Sin(), v.Y.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sinh (this DVector2 v) => new DVector2(v.X.Sinh(), v.Y.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sqrt (this DVector2 v) => new DVector2(v.X.Sqrt(), v.Y.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Tan (this DVector2 v) => new DVector2(v.X.Tan(), v.Y.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Tanh (this DVector2 v) => new DVector2(v.X.Tanh(), v.Y.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Inverse (this DVector2 v) => new DVector2(v.X.Inverse(), v.Y.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Ceiling (this DVector2 v) => new DVector2(v.X.Ceiling(), v.Y.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Floor (this DVector2 v) => new DVector2(v.X.Floor(), v.Y.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Round (this DVector2 v) => new DVector2(v.X.Round(), v.Y.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Truncate (this DVector2 v) => new DVector2(v.X.Truncate(), v.Y.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sqr (this DVector2 v) => new DVector2(v.X.Sqr(), v.Y.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cube (this DVector2 v) => new DVector2(v.X.Cube(), v.Y.Cube());

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector3 v1, DVector3 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector3 v1, DVector3 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector3 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector3 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Normalize(this DVector3 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector3 v1, DVector3 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Min(this DVector3 v1, DVector3 v2) => new DVector3(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Max(this DVector3 v1, DVector3 v2) => new DVector3(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 SquareRoot (this DVector3 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Abs (this DVector3 v) => new DVector3(v.X.Abs(), v.Y.Abs(), v.Z.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Acos (this DVector3 v) => new DVector3(v.X.Acos(), v.Y.Acos(), v.Z.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Asin (this DVector3 v) => new DVector3(v.X.Asin(), v.Y.Asin(), v.Z.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Atan (this DVector3 v) => new DVector3(v.X.Atan(), v.Y.Atan(), v.Z.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cos (this DVector3 v) => new DVector3(v.X.Cos(), v.Y.Cos(), v.Z.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cosh (this DVector3 v) => new DVector3(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Exp (this DVector3 v) => new DVector3(v.X.Exp(), v.Y.Exp(), v.Z.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Log (this DVector3 v) => new DVector3(v.X.Log(), v.Y.Log(), v.Z.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Log10 (this DVector3 v) => new DVector3(v.X.Log10(), v.Y.Log10(), v.Z.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sin (this DVector3 v) => new DVector3(v.X.Sin(), v.Y.Sin(), v.Z.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sinh (this DVector3 v) => new DVector3(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sqrt (this DVector3 v) => new DVector3(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Tan (this DVector3 v) => new DVector3(v.X.Tan(), v.Y.Tan(), v.Z.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Tanh (this DVector3 v) => new DVector3(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Inverse (this DVector3 v) => new DVector3(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Ceiling (this DVector3 v) => new DVector3(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Floor (this DVector3 v) => new DVector3(v.X.Floor(), v.Y.Floor(), v.Z.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Round (this DVector3 v) => new DVector3(v.X.Round(), v.Y.Round(), v.Z.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Truncate (this DVector3 v) => new DVector3(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sqr (this DVector3 v) => new DVector3(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cube (this DVector3 v) => new DVector3(v.X.Cube(), v.Y.Cube(), v.Z.Cube());

		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector4 v1, DVector4 v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector4 v1, DVector4 v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector4 v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector4 v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Normalize(this DVector4 v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector4 v1, DVector4 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Min(this DVector4 v1, DVector4 v2) => new DVector4(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z), v1.W.Min(v2.W));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Max(this DVector4 v1, DVector4 v2) => new DVector4(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z), v1.W.Max(v2.W));
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 SquareRoot (this DVector4 v) => v.Sqrt(); 
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Abs (this DVector4 v) => new DVector4(v.X.Abs(), v.Y.Abs(), v.Z.Abs(), v.W.Abs());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Acos (this DVector4 v) => new DVector4(v.X.Acos(), v.Y.Acos(), v.Z.Acos(), v.W.Acos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Asin (this DVector4 v) => new DVector4(v.X.Asin(), v.Y.Asin(), v.Z.Asin(), v.W.Asin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Atan (this DVector4 v) => new DVector4(v.X.Atan(), v.Y.Atan(), v.Z.Atan(), v.W.Atan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cos (this DVector4 v) => new DVector4(v.X.Cos(), v.Y.Cos(), v.Z.Cos(), v.W.Cos());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cosh (this DVector4 v) => new DVector4(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh(), v.W.Cosh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Exp (this DVector4 v) => new DVector4(v.X.Exp(), v.Y.Exp(), v.Z.Exp(), v.W.Exp());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Log (this DVector4 v) => new DVector4(v.X.Log(), v.Y.Log(), v.Z.Log(), v.W.Log());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Log10 (this DVector4 v) => new DVector4(v.X.Log10(), v.Y.Log10(), v.Z.Log10(), v.W.Log10());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sin (this DVector4 v) => new DVector4(v.X.Sin(), v.Y.Sin(), v.Z.Sin(), v.W.Sin());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sinh (this DVector4 v) => new DVector4(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh(), v.W.Sinh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sqrt (this DVector4 v) => new DVector4(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt(), v.W.Sqrt());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Tan (this DVector4 v) => new DVector4(v.X.Tan(), v.Y.Tan(), v.Z.Tan(), v.W.Tan());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Tanh (this DVector4 v) => new DVector4(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh(), v.W.Tanh());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Inverse (this DVector4 v) => new DVector4(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse(), v.W.Inverse());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Ceiling (this DVector4 v) => new DVector4(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling(), v.W.Ceiling());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Floor (this DVector4 v) => new DVector4(v.X.Floor(), v.Y.Floor(), v.Z.Floor(), v.W.Floor());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Round (this DVector4 v) => new DVector4(v.X.Round(), v.Y.Round(), v.Z.Round(), v.W.Round());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Truncate (this DVector4 v) => new DVector4(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate(), v.W.Truncate());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sqr (this DVector4 v) => new DVector4(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr(), v.W.Sqr());
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cube (this DVector4 v) => new DVector4(v.X.Cube(), v.Y.Cube(), v.Z.Cube(), v.W.Cube());


} } 
