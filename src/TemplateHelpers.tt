<#@ import namespace="System.Linq" #>
<#+
	// MIT License 
	// Copyright (C) 2019 Ara 3D. Inc
	// https://ara3d.com

	private void CreateSetter(string name, int i, string[] fields, string[] types)
	{
	   var field = fields[i];
	   var type = types[i];
	   var sb = new StringBuilder();
	   
	   for (var j=0; j < fields.Length; ++j) {
			if (j > 0) sb.Append(", ");
			sb.Append(j == i ? "x" : fields[j]);
		}
		var args = sb.ToString();
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= name #> Set<#= field #>(<#= type #> x) => new <#= name #>(<#= args #>);
<#+
	}
	
	private void CreateSetters(string name, string[] fields, string[] types) {
		for (var i=0; i < fields.Length; ++i) 
			CreateSetter(name, i, fields, types);
	}

    private void CreateShapeStruct(string name, string[] fields, string type)
	{
		CreateStruct(name, fields, fields.Select(f => type).ToArray());
	}

    private void CreateVectorStruct(string name, string[] fields, string type)
	{
		CreateStruct(name, fields, fields.Select(f => type).ToArray(), true);
	}

	private void CreateRangeStruct(string name, string type) 
	{
		CreateStruct(name, new[] { "Min", "Max" }, new[] { type, type });
	}

	private static string ZeroValue(string type) {
		switch (type)
		{
		case "int": return "0";
		case "float": return "0f";
		case "double": return "0.0";
		case "long": return "0L";
		default: return type + ".Zero";
		}
	}

	private static string OneValue(string type) {
		switch (type)
		{
		case "int": return "1";
		case "float": return "1f";
		case "double": return "1.0";
		case "long": return "1L";
		default: return type + ".One";
		}
	}

	private void CreateBinaryOp(string name, string[] fields, string type, string op)
	{
		var combineArgs0 = string.Join(",", fields.Select(f => $"value1.{f} {op} value2.{f}"));
		var combineArgs1 = string.Join(",", fields.Select(f => $"value1.{f} {op} value2"));
		var combineArgs2 = string.Join(",", fields.Select(f => $"value1 {op} value2.{f}"));
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= name #> operator <#= op #>(<#= name #> value1, <#= name #> value2) => new <#= name #>(<#= combineArgs0 #>);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= name #> operator <#= op #>(<#= name #> value1, <#= type #> value2) => new <#= name #>(<#= combineArgs1 #>);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= name #> operator <#= op #>(<#= type #> value1, <#= name #> value2) => new <#= name #>(<#= combineArgs2 #>);
<#+
	}

	private void CreateVectorOps(string name, string[] fields, string type)
	{
		CreateBinaryOp(name, fields, type, "+");
		CreateBinaryOp(name, fields, type, "-");
		CreateBinaryOp(name, fields, type, "*");
		CreateBinaryOp(name, fields, type, "/");

		var ctorArgs = string.Join(", ", fields.Select(f => "value"));
		var dotArgs = string.Join(" + ", fields.Select(f => $"value1.{f} * value2.{f}"));
		var one = OneValue(type);
		var compareBody = string.Join(" && ", fields.Select(f => $"{f}.Abs() < tolerance"));
		var indexBody = string.Join(" : ", fields.Select((f, i) => $"n == {i} ? {f}"));

		var minBody = string.Join(".Min", fields.Select(f => $"({f})"));
		var maxBody = string.Join(".Max", fields.Select(f => $"({f})"));
		var sumBody = string.Join(" + ", fields.Select(f => $"({f})"));
		var sumSqrBody = string.Join(" + ", fields.Select(f => $"({f}).Sqr()"));
		var productBody = string.Join(" * ", fields.Select(f => $"({f})"));
		var isNanBody = string.Join(" || ", fields.Select(f => $"{f}.IsNaN()"));
	
#>
		public static <#= name #> One = new <#= name #>(<#= one #>);
<#+
		foreach (var f in fields) {
#>
		public static <#= name #> Unit<#= f #> = Zero.Set<#= f #>(<#= one #>);
<#+
		}

#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= name #>(<#= type #> value) : this(<#= ctorArgs #>) { }		
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= name #> operator -(<#= name #> value) => Zero - value;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= type #> Dot(<#= name #> value1, <#= name #> value2) => <#= dotArgs #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> Dot(<#= name #> value) => <#= name #>.Dot(this, value);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => <#= compareBody #>;	
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(<#= name #> value, float tolerance = Constants.Tolerance) => (this - value).AlmostZero(tolerance);	
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => <#= isNanBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> MinComponent() => <#= minBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> MaxComponent() => <#= maxBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> SumComponents() => <#= sumBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> SumSqrComponents() => <#= sumSqrBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= type #> ProductComponents() => <#= productBody #>;
<#+
	}

    private void CreateStruct(string name, string[] fields, string[] types, bool isVector = false)
    {
        var toStringBodyInner = string.Join(", ", fields.Select((f) => $"{f} = {{{f}}}"));
        var toStringBody = $"{name}({toStringBodyInner})";
        var hashBodyInner = string.Join(", ", fields.Select((f) => $"{f}.GetHashCode()"));
        var hashBody = $"Hash.Combine({hashBodyInner})";
		var eqBody = string.Join(" && ",fields.Select((f) => $"{f} == x.{f}"));
        var opArgs = $"{name} x0, {name} x1";				
		var ctorArgs = string.Join(", ", fields.Zip(types, (field, type) => $"{type} {field.ToLower()}"));
		var ctorAssign = string.Join(" ", fields.Select((f) => $"{f} = {f.ToLower()};"));
		var defaultArgs = string.Join(", ", types.Select(t => $"default"));
		var minArgs = string.Join(", ", types.Select(t => $"{t}.MinValue"));
		var maxArgs = string.Join(", ", types.Select(t => $"{t}.MaxValue"));

#>
	[StructLayout(LayoutKind.Sequential, Pack=4)]
	[DataContract]
	public readonly partial struct <#= name #> : IEquatable< <#= name #> >
	{ 
<#+
        for (var i=0; i < fields.Length; ++i) {
#>
		[DataMember]
		public readonly <#= types[i] #> <#= fields[i] #>;
<#+
		}		
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public <#= name #>(<#= ctorArgs #>) { <#= ctorAssign #> }
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is <#= name #> x && Equals(x);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => <#= hashBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"<#= toStringBody #>";
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(<#= name #> x) => <#= eqBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(<#= opArgs #>) => x0.Equals(x1);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(<#= opArgs #>) => !x0.Equals(x1);
		public static <#= name #> Zero = new <#= name #>(<#= defaultArgs #>);
		public static <#= name #> MinValue = new <#= name #>(<#= minArgs #>);
		public static <#= name #> MaxValue = new <#= name #>(<#= maxArgs #>);
<#+
		CreateSetters(name, fields, types); 
		if (isVector) CreateVectorOps(name, fields, types[0]);
#>
	}
<#+
	}
#>