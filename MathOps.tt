<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
// AUTOGENERATED FILE: Do not edit directly, instead edit MathOps.tt

// MIT License - Copyright (C) Ara 3D, Inc.
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

<# 
var intTypes = new[] { "int", "long" };
var floatTypes = new[] { "float", "double" };
var nonVectorTypes = intTypes.Concat(floatTypes);
var comparableTypes = nonVectorTypes;
var vectorTypes = new[] { "Vector2", "Vector3", "Vector4" };
var types = nonVectorTypes.Concat(vectorTypes);
var araBinaryOps = new[] { "Add", "Sub", "Mul", "Div" };
var araUnaryOps = new[] { "Inverse", "Ceiling", "Floor", "Round", "Truncate", "Sqr", "Cube" };
var araCompOps = new[] { "Gt", "Lt", "GtEq", "LtEq", "Eq", "NEq" };
var sysUnaryOps = new[] { "Acos", "Asin", "Atan", "Cos", "Cosh", "Exp", "Log", "Log10", "Sin", "Sinh", "Tan", "Tanh" };
var sysBinaryOps = new[] { "Atan2", "Log", "Pow" };
var allUnaryOps = sysUnaryOps.Concat(araUnaryOps);
#>

using System.Numerics;

namespace Ara3D 
{
	public static class MathOps {

<# 
foreach (var t in types) { 
#>
        public static <#= t #> Add (this <#= t #> v1, <#= t #> v2) { return v1 + v2; }
        public static <#= t #> Sub (this <#= t #> v1, <#= t #> v2) { return v1 - v2; }
        public static <#= t #> Mul (this <#= t #> v1, <#= t #> v2) { return v1 * v2; }
        public static <#= t #> Div (this <#= t #> v1, <#= t #> v2) { return v1 / v2; }
		public static <#= t #> Neg (this <#= t #> v) { return -v; }
<# } #>

<#
foreach (var t in nonVectorTypes) { 
#>
        public static <#= t #> Min (this <#= t #> v1, <#= t #> v2) { return System.Math.Min(v1, v2); }
        public static <#= t #> Max (this <#= t #> v1, <#= t #> v2) { return System.Math.Max(v1, v2); }
<# } #>

<#
foreach (var t in comparableTypes) { 
#>
        public static bool Gt (this <#= t #> v1, <#= t #> v2) { return v1 > v2; }
        public static bool Lt (this <#= t #> v1, <#= t #> v2) { return v1 < v2; }
        public static bool GtEq (this <#= t #> v1, <#= t #> v2) { return v1 >= v2; }
        public static bool LtEq (this <#= t #> v1, <#= t #> v2) { return v1 <= v2; }
        public static bool Eq (this <#= t #> v1, <#= t #> v2) { return v1 == v2; }
        public static bool NEq (this <#= t #> v1, <#= t #> v2) { return v1 != v2; }
<# } #>

		public static bool And (this bool a, bool b) { return a && b; }
		public static bool Or (this bool a, bool b) { return a || b; }
		public static bool NAnd (this bool a, bool b) { return !(a && b); }
		public static bool XOr (this bool a, bool b) { return a || b && !(a && b); }
		public static bool NOr (this bool a, bool b) { return !(a || b); }
		public static bool Not (this bool a) { return !a; }
		public static bool Eq (this bool a, bool b) { return a == b; }
		public static bool NEq ( this bool a, bool b) { return a != b; } 

<# 
foreach (var t in intTypes) { 
#>
		public static <#= t #> And (this <#= t #> a, <#= t #> b) { return a & b; }
		public static <#= t #> Or (this <#= t #> a, <#= t #> b) { return a | b; }
		public static <#= t #> NAnd (this <#= t #> a, <#= t #> b) { return ~(a & b); }
		public static <#= t #> XOr (this <#= t #> a, <#= t #> b) { return a | b & ~(a & b); }
		public static <#= t #> NOr (this <#= t #> a, <#= t #> b) { return ~(a | b); }
		public static <#= t #> Not (this <#= t #> a) { return ~a; }
<# } #>

<# 
foreach (var op in sysUnaryOps) { 
#>
		public static double <#= op #> (this double x) { return System.Math.<#= op #>(x); }
		public static float <#= op #> (this float x) { return (float)System.Math.<#= op #>(x); }
<# } #>
		public static double Sqrt (this double x) { return System.Math.Sqrt(x); }
		public static float Sqrt (this float x) { return (float)System.Math.Sqrt(x); }

<# 
foreach (var t in floatTypes) { 
#>
		public static <#= t #> Sqr (this <#= t #> x) { return x * x; }
		public static <#= t #> Cube (this <#= t #> x) { return x * x * x; }
		public static <#= t #> Negate (this <#= t #> x) { return -x; }
		public static <#= t #> Abs(this <#= t #> x) { return (<#= t #>)System.Math.Abs(x); }
		public static <#= t #> Inverse (this <#= t #> x) { return (<#= t #>)1 / x; }
		public static <#= t #> Truncate (this <#= t #> x) { return (<#= t #>)System.Math.Truncate(x); }
		public static <#= t #> Ceiling (this <#= t #> x) { return (<#= t #>)System.Math.Ceiling(x); }
		public static <#= t #> Floor (this <#= t #> x) { return (<#= t #>)System.Math.Floor(x); }
		public static <#= t #> Round (this <#= t #> x) { return (<#= t #>)System.Math.Round(x); }
<# } #>

<# 
foreach (var op in allUnaryOps) { 
#>
		public static Vector2 <#= op #> (this Vector2 x) { return x.Select(MathOps.<#= op #>); }
		public static Vector3 <#= op #> (this Vector3 x) { return x.Select(MathOps.<#= op #>); }
		public static Vector4 <#= op #> (this Vector4 x) { return x.Select(MathOps.<#= op #>); }
<# } #>

<# 
foreach (var t in vectorTypes) { 
#>
		public static <#= t #> Abs( this <#= t #> x) { return <#= t #>.Abs(x); }
		public static <#= t #> Clamp( this <#= t #> self, <#= t #> min, <#= t #> max) { return <#= t #>.Clamp(self, min, max); }
		public static <#= t #> Lerp( this <#= t #> self, <#= t #> x, float amount) { return <#= t #>.Lerp(self, x, amount); }
		public static <#= t #> Average( this <#= t #> self, <#= t #> x) { return self.Lerp(x, 0.5f); }
		public static float Distance( this <#= t #> self, <#= t #> v) { return <#= t #>.Distance(self, v); }
		public static float DistanceSquared( this <#= t #> self, <#= t #> v) { return <#= t #>.DistanceSquared(self, v); }
		public static float Dot( this <#= t #> self, <#= t #> v) { return <#= t #>.Dot(self, v); }
		public static <#= t #> Min( this <#= t #> self, <#= t #> v) { return <#= t #>.Min(self, v); }
		public static <#= t #> Max( this <#= t #> self, <#= t #> v) { return <#= t #>.Min(self, v); }
		public static <#= t #> Negate( this <#= t #> self) { return <#= t #>.Negate(self); }
		public static <#= t #> Normal( this <#= t #> self) { return <#= t #>.Normalize(self); }
		public static <#= t #> Sqrt( this <#= t #> self) { return <#= t #>.SquareRoot(self); }
<#  } #>

		public static Vector3 Cross( this Vector3 self, Vector3 x ) { return Vector3.Cross(self, x); }

} } 
