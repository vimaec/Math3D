<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
// AUTOGENERATED FILE: Do not edit directly, instead edit MathOps.tt

<#
var intTypes = new[] { "int", "long" };
var floatTypes = new[] { "float", "double" };
var nonVectorTypes = intTypes.Concat(floatTypes);
var comparableTypes = nonVectorTypes;
var vectorTypes = new[] { "Vector2", "Vector3", "Vector4", "DVector2", "DVector3", "DVector4" };
var floatAndVectorTypes = floatTypes.Concat(vectorTypes);
var types = nonVectorTypes.Concat(vectorTypes);
var araBinaryOps = new[] { "Add", "Subtract", "Multiply", "Divide" };
var araCompOps = new[] { "Gt", "Lt", "GtEq", "LtEq", "Eq", "NEq" };
var sysBinaryOps = new[] { "Atan2", "Log", "Pow" };
var araUnaryOps = new[] { "Inverse", "Ceiling", "Floor", "Round", "Truncate", "Sqr", "Cube", "ToRadians", "ToDegrees" };
var sysUnaryOps = new[] { "Abs", "Acos", "Asin", "Atan", "Cos", "Cosh", "Exp", "Log", "Log10", "Sin", "Sinh", "Sqrt", "Tan", "Tanh" };
var allUnaryOps = sysUnaryOps.Concat(araUnaryOps);
#>
using System;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable once CheckNamespace
namespace Vim.Math3d
{
    public static partial class MathOps
    {
<#
foreach (var op in sysUnaryOps) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double <#= op #>(this double x) => Math.<#= op #>(x);
<# } #>

<#
foreach (var op in sysUnaryOps) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float <#= op #>(this float x) => (float)Math.<#= op #>(x);
<# } #>

<#
foreach (var t in floatTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Sign(this <#= t #> x) => x > 0 ? 1 : x < 0 ? -1 : 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Magnitude(this <#= t #> x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> MagnitudeSquared(this <#= t #> x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Inverse (this <#= t #> x) => (<#= t #>)1 / x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Truncate (this <#= t #> x) => (<#= t #>)Math.Truncate(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Ceiling (this <#= t #> x) => (<#= t #>)Math.Ceiling(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Floor (this <#= t #> x) => (<#= t #>)Math.Floor(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Round (this <#= t #> x) => (<#= t #>)System.Math.Round(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> ToRadians(this <#= t #> x) => (<#= t #>)(x * Constants.DegreesToRadians);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> ToDegrees(this <#= t #> x) => (<#= t #>)(x * Constants.RadiansToDegrees);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Distance(this <#= t #> v1, <#= t #> v2) => (v1 - v2).Abs();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity(this <#= t #> v) => <#= t #>.IsInfinity(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN(this <#= t #> v) => <#= t #>.IsNaN(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostEquals(this <#= t #> v1, <#= t #> v2, float tolerance = Constants.Tolerance) => (v2 - v1).AlmostZero(tolerance);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostZero(this <#= t #> v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Smoothstep(this <#= t #> v) => v * v * (3 - 2 * v);
<# } #>

<#
foreach (var t in types) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Add (this <#= t #> v1, <#= t #> v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Subtract (this <#= t #> v1, <#= t #> v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Multiply (this <#= t #> v1, <#= t #> v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Divide (this <#= t #> v1, <#= t #> v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Negate (this <#= t #> v) => -v;
<# } #>

<#
foreach (var t in nonVectorTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this <#= t #> v, <#= t #> min, <#= t #> max) => v >= min && v < max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Sqr (this <#= t #> x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Cube (this <#= t #> x) => x * x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Min (this <#= t #> v1, <#= t #> v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Max (this <#= t #> v1, <#= t #> v2) => Math.Max(v1, v2);
<# } #>

<#
foreach (var t in comparableTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this <#= t #> v1, <#= t #> v2) => v1 > v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this <#= t #> v1, <#= t #> v2) => v1 < v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this <#= t #> v1, <#= t #> v2) => v1 >= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this <#= t #> v1, <#= t #> v2) => v1 <= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this <#= t #> v1, <#= t #> v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this <#= t #> v1, <#= t #> v2) => v1 != v2;
<# } #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool And (this bool a, bool b) => a && b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Or (this bool a, bool b) => a || b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NAnd (this bool a, bool b) => !(a && b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool XOr (this bool a, bool b) => a || b && !(a && b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NOr (this bool a, bool b) => !(a || b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Not (this bool a) => !a;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this bool a, bool b) => a == b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq ( this bool a, bool b) => a != b;

<#
foreach (var t in intTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Magnitude(this <#= t #> x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> MagnitudeSquared(this <#= t #> x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> And (this <#= t #> a, <#= t #> b) => a & b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Or (this <#= t #> a, <#= t #> b) => a | b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> NAnd (this <#= t #> a, <#= t #> b) => ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> XOr (this <#= t #> a, <#= t #> b) => a | b & ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> NOr (this <#= t #> a, <#= t #> b) => ~(a | b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Not (this <#= t #> a) => ~a;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Abs (this <#= t #> a) => Math.Abs(a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> DivideRoundUp (this <#= t #> a, <#= t #> b) => a / b + (a % b > 0 ? 1 : 0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsEven (this <#= t #> n) => n % 2 == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsOdd (this <#= t #> n) => n % 2 == 1;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsPowerOfTwo (this <#= t #> v) => v > 0 && (v & (v - 1)) == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity (this <#= t #> n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN (this <#= t #> n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= t #> Clamp (this <#= t #> v, <#= t #> min, <#= t #> max) => v.Min(max).Max(min);
<# } #>

<#
foreach (var v in floatAndVectorTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Lerp(this <#= v #> v1, <#= v #> v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> InverseLerp(this <#= v #> v, <#= v #> a, <#= v #> b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> LerpPrecise(this <#= v #> v1, <#= v #> v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> ClampLower(this <#= v #> v, <#= v #> min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> ClampUpper(this <#= v #> v, <#= v #> max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Clamp(this <#= v #> v, <#= v #> min, <#= v #> max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Average(this <#= v #> v1, <#= v #> v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Barycentric(this <#= v #> v1, <#= v #> v2, <#= v #> v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
<# } #>


<#
// TODO: I want to support all things that can be added / subtracted together.
foreach (var v in vectorTypes) {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< <#= v #> > Stats(this IEnumerable< <#= v #> > self)
            => self.Aggregate(Stats< <#= v #> >.Default, (a, b) => new Stats< <#= v #> >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Average(this Stats< <#= v #> > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Extents(this Stats< <#= v #> > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Middle(this Stats< <#= v #> > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Sum(this IEnumerable< <#= v #> > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Average(this IEnumerable< <#= v #> > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Min(this IEnumerable< <#= v #> > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Max(this IEnumerable< <#= v #> > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Extents(this IEnumerable< <#= v #> > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Middle(this IEnumerable< <#= v #> > self) => self.Stats().Middle();
<# } #>


<#
for (var i=0; i < vectorTypes.Length; ++i) {
    var v = vectorTypes[i];
    var s = i < 3 ? "float" : "double";
    var fields = (new [] { "X", "Y", "Z", "W" }).Take(i % 3 + 2);
    var dotBody = string.Join(" + ", fields.Select(f => $"v1.{f} * v2.{f}"));
    var minBody = $"new {v}(" + string.Join(", ", fields.Select(f => $"v1.{f}.Min(v2.{f})")) + ")";
    var maxBody = $"new {v}(" + string.Join(", ", fields.Select(f => $"v1.{f}.Max(v2.{f})")) + ")";
    var enumBody = string.Join(" ", fields.Select(f => $"yield return v.{f};"));
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> DistanceSquared(this <#= v #> v1, <#= v #> v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Distance(this <#= v #> v1, <#= v #> v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> LengthSquared(this <#= v #> v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Length(this <#= v #> v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Normalize(this <#= v #> v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> SafeNormalize(this <#= v #> v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Dot(this <#= v #> v1, <#= v #> v2) => <#= dotBody #>;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Min(this <#= v #> v1, <#= v #> v2) => <#= minBody #>;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Max(this <#= v #> v1, <#= v #> v2) => <#= maxBody #>;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> SquareRoot (this <#= v #> v) => v.Sqrt();

<#
    foreach (var op in allUnaryOps) {
        var opBody = string.Join(", ", fields.Select(f => $"v.{f}.{op}()"));
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> <#= op #> (this <#= v #> v) => new <#= v #>(<#= opBody #>);
<# } #>

<# } #>

} }
