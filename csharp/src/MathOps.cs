// AUTOGENERATED FILE: Do not edit directly, instead edit MathOps.tt

using System;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable once CheckNamespace
namespace Vim.Math3d
{
    public static partial class MathOps
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Abs(this double x) => Math.Abs(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Acos(this double x) => Math.Acos(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Asin(this double x) => Math.Asin(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Atan(this double x) => Math.Atan(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cos(this double x) => Math.Cos(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cosh(this double x) => Math.Cosh(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Exp(this double x) => Math.Exp(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Log(this double x) => Math.Log(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Log10(this double x) => Math.Log10(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sin(this double x) => Math.Sin(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sinh(this double x) => Math.Sinh(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sqrt(this double x) => Math.Sqrt(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Tan(this double x) => Math.Tan(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Tanh(this double x) => Math.Tanh(x);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Abs(this float x) => (float)Math.Abs(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Acos(this float x) => (float)Math.Acos(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Asin(this float x) => (float)Math.Asin(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Atan(this float x) => (float)Math.Atan(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cos(this float x) => (float)Math.Cos(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cosh(this float x) => (float)Math.Cosh(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Exp(this float x) => (float)Math.Exp(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Log(this float x) => (float)Math.Log(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Log10(this float x) => (float)Math.Log10(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sin(this float x) => (float)Math.Sin(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sinh(this float x) => (float)Math.Sinh(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sqrt(this float x) => (float)Math.Sqrt(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Tan(this float x) => (float)Math.Tan(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Tanh(this float x) => (float)Math.Tanh(x);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Sign(this float x) => x > 0 ? 1 : x < 0 ? -1 : 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Magnitude(this float x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float MagnitudeSquared(this float x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Inverse (this float x) => (float)1 / x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Truncate (this float x) => (float)Math.Truncate(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Ceiling (this float x) => (float)Math.Ceiling(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Floor (this float x) => (float)Math.Floor(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Round (this float x) => (float)System.Math.Round(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ToRadians(this float x) => (float)(x * Constants.DegreesToRadians);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ToDegrees(this float x) => (float)(x * Constants.RadiansToDegrees);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this float v1, float v2) => (v1 - v2).Abs();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity(this float v) => float.IsInfinity(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN(this float v) => float.IsNaN(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostEquals(this float v1, float v2, float tolerance = Constants.Tolerance) => (v2 - v1).AlmostZero(tolerance);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostZero(this float v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Smoothstep(this float v) => v * v * (3 - 2 * v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Sign(this double x) => x > 0 ? 1 : x < 0 ? -1 : 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Magnitude(this double x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double MagnitudeSquared(this double x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Inverse (this double x) => (double)1 / x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Truncate (this double x) => (double)Math.Truncate(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Ceiling (this double x) => (double)Math.Ceiling(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Floor (this double x) => (double)Math.Floor(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Round (this double x) => (double)System.Math.Round(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ToRadians(this double x) => (double)(x * Constants.DegreesToRadians);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ToDegrees(this double x) => (double)(x * Constants.RadiansToDegrees);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this double v1, double v2) => (v1 - v2).Abs();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity(this double v) => double.IsInfinity(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN(this double v) => double.IsNaN(v);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostEquals(this double v1, double v2, float tolerance = Constants.Tolerance) => (v2 - v1).AlmostZero(tolerance);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool AlmostZero(this double v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Smoothstep(this double v) => v * v * (3 - 2 * v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Add (this int v1, int v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Subtract (this int v1, int v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Multiply (this int v1, int v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Divide (this int v1, int v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Negate (this int v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Add (this long v1, long v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Subtract (this long v1, long v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Multiply (this long v1, long v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Divide (this long v1, long v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Negate (this long v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Add (this float v1, float v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Subtract (this float v1, float v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Multiply (this float v1, float v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Divide (this float v1, float v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Negate (this float v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Add (this double v1, double v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Subtract (this double v1, double v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Multiply (this double v1, double v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Divide (this double v1, double v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Negate (this double v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Add (this Vector2 v1, Vector2 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Subtract (this Vector2 v1, Vector2 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Multiply (this Vector2 v1, Vector2 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Divide (this Vector2 v1, Vector2 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Negate (this Vector2 v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Add (this Vector3 v1, Vector3 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Subtract (this Vector3 v1, Vector3 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Multiply (this Vector3 v1, Vector3 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Divide (this Vector3 v1, Vector3 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Negate (this Vector3 v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Add (this Vector4 v1, Vector4 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Subtract (this Vector4 v1, Vector4 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Multiply (this Vector4 v1, Vector4 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Divide (this Vector4 v1, Vector4 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Negate (this Vector4 v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Add (this DVector2 v1, DVector2 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Subtract (this DVector2 v1, DVector2 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Multiply (this DVector2 v1, DVector2 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Divide (this DVector2 v1, DVector2 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Negate (this DVector2 v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Add (this DVector3 v1, DVector3 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Subtract (this DVector3 v1, DVector3 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Multiply (this DVector3 v1, DVector3 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Divide (this DVector3 v1, DVector3 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Negate (this DVector3 v) => -v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Add (this DVector4 v1, DVector4 v2) => v1 + v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Subtract (this DVector4 v1, DVector4 v2) => v1 - v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Multiply (this DVector4 v1, DVector4 v2) => v1 * v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Divide (this DVector4 v1, DVector4 v2) => v1 / v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Negate (this DVector4 v) => -v;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this int v, int min, int max) => v >= min && v < max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Sqr (this int x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Cube (this int x) => x * x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Min (this int v1, int v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Max (this int v1, int v2) => Math.Max(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this long v, long min, long max) => v >= min && v < max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Sqr (this long x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Cube (this long x) => x * x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Min (this long v1, long v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Max (this long v1, long v2) => Math.Max(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this float v, float min, float max) => v >= min && v < max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Sqr (this float x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Cube (this float x) => x * x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Min (this float v1, float v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Max (this float v1, float v2) => Math.Max(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Within(this double v, double min, double max) => v >= min && v < max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Sqr (this double x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Cube (this double x) => x * x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Min (this double v1, double v2) => Math.Min(v1, v2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Max (this double v1, double v2) => Math.Max(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this int v1, int v2) => v1 > v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this int v1, int v2) => v1 < v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this int v1, int v2) => v1 >= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this int v1, int v2) => v1 <= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this int v1, int v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this int v1, int v2) => v1 != v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this long v1, long v2) => v1 > v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this long v1, long v2) => v1 < v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this long v1, long v2) => v1 >= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this long v1, long v2) => v1 <= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this long v1, long v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this long v1, long v2) => v1 != v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this float v1, float v2) => v1 > v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this float v1, float v2) => v1 < v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this float v1, float v2) => v1 >= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this float v1, float v2) => v1 <= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this float v1, float v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this float v1, float v2) => v1 != v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Gt (this double v1, double v2) => v1 > v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Lt (this double v1, double v2) => v1 < v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool GtEq (this double v1, double v2) => v1 >= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool LtEq (this double v1, double v2) => v1 <= v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this double v1, double v2) => v1 == v2;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq (this double v1, double v2) => v1 != v2;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool And (this bool a, bool b) => a && b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Or (this bool a, bool b) => a || b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NAnd (this bool a, bool b) => !(a && b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool XOr (this bool a, bool b) => a || b && !(a && b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NOr (this bool a, bool b) => !(a || b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Not (this bool a) => !a;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool Eq (this bool a, bool b) => a == b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool NEq ( this bool a, bool b) => a != b;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Magnitude(this int x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int MagnitudeSquared(this int x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int And (this int a, int b) => a & b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Or (this int a, int b) => a | b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int NAnd (this int a, int b) => ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int XOr (this int a, int b) => a | b & ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int NOr (this int a, int b) => ~(a | b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Not (this int a) => ~a;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Abs (this int a) => Math.Abs(a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int DivideRoundUp (this int a, int b) => a / b + (a % b > 0 ? 1 : 0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsEven (this int n) => n % 2 == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsOdd (this int n) => n % 2 == 1;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsPowerOfTwo (this int v) => v > 0 && (v & (v - 1)) == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity (this int n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN (this int n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Clamp (this int v, int min, int max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Magnitude(this long x) => x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long MagnitudeSquared(this long x) => x * x;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long And (this long a, long b) => a & b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Or (this long a, long b) => a | b;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long NAnd (this long a, long b) => ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long XOr (this long a, long b) => a | b & ~(a & b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long NOr (this long a, long b) => ~(a | b);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Not (this long a) => ~a;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Abs (this long a) => Math.Abs(a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long DivideRoundUp (this long a, long b) => a / b + (a % b > 0 ? 1 : 0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsEven (this long n) => n % 2 == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsOdd (this long n) => n % 2 == 1;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsPowerOfTwo (this long v) => v > 0 && (v & (v - 1)) == 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsInfinity (this long n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool IsNaN (this long n) => false;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static long Clamp (this long v, long min, long max) => v.Min(max).Max(min);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Lerp(this float v1, float v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float InverseLerp(this float v, float a, float b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LerpPrecise(this float v1, float v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ClampLower(this float v, float min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float ClampUpper(this float v, float max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Clamp(this float v, float min, float max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Average(this float v1, float v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Barycentric(this float v1, float v2, float v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Lerp(this double v1, double v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double InverseLerp(this double v, double a, double b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LerpPrecise(this double v1, double v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ClampLower(this double v, double min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double ClampUpper(this double v, double max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Clamp(this double v, double min, double max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Average(this double v1, double v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Barycentric(this double v1, double v2, double v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Lerp(this Vector2 v1, Vector2 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 InverseLerp(this Vector2 v, Vector2 a, Vector2 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 LerpPrecise(this Vector2 v1, Vector2 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ClampLower(this Vector2 v, Vector2 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ClampUpper(this Vector2 v, Vector2 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Clamp(this Vector2 v, Vector2 min, Vector2 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Average(this Vector2 v1, Vector2 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Barycentric(this Vector2 v1, Vector2 v2, Vector2 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Lerp(this Vector3 v1, Vector3 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 InverseLerp(this Vector3 v, Vector3 a, Vector3 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 LerpPrecise(this Vector3 v1, Vector3 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ClampLower(this Vector3 v, Vector3 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ClampUpper(this Vector3 v, Vector3 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Clamp(this Vector3 v, Vector3 min, Vector3 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Average(this Vector3 v1, Vector3 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Barycentric(this Vector3 v1, Vector3 v2, Vector3 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Lerp(this Vector4 v1, Vector4 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 InverseLerp(this Vector4 v, Vector4 a, Vector4 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 LerpPrecise(this Vector4 v1, Vector4 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ClampLower(this Vector4 v, Vector4 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ClampUpper(this Vector4 v, Vector4 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Clamp(this Vector4 v, Vector4 min, Vector4 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Average(this Vector4 v1, Vector4 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Barycentric(this Vector4 v1, Vector4 v2, Vector4 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Lerp(this DVector2 v1, DVector2 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 InverseLerp(this DVector2 v, DVector2 a, DVector2 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 LerpPrecise(this DVector2 v1, DVector2 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ClampLower(this DVector2 v, DVector2 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ClampUpper(this DVector2 v, DVector2 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Clamp(this DVector2 v, DVector2 min, DVector2 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Average(this DVector2 v1, DVector2 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Barycentric(this DVector2 v1, DVector2 v2, DVector2 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Lerp(this DVector3 v1, DVector3 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 InverseLerp(this DVector3 v, DVector3 a, DVector3 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 LerpPrecise(this DVector3 v1, DVector3 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ClampLower(this DVector3 v, DVector3 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ClampUpper(this DVector3 v, DVector3 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Clamp(this DVector3 v, DVector3 min, DVector3 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Average(this DVector3 v1, DVector3 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Barycentric(this DVector3 v1, DVector3 v2, DVector3 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Lerp(this DVector4 v1, DVector4 v2, float t) => v1 + (v2 - v1) * t;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 InverseLerp(this DVector4 v, DVector4 a, DVector4 b) => (v - a) / (b - a);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 LerpPrecise(this DVector4 v1, DVector4 v2, float t) => ((1 - t) * v1) + (v2 * t);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ClampLower(this DVector4 v, DVector4 min) => v.Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ClampUpper(this DVector4 v, DVector4 max) => v.Min(max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Clamp(this DVector4 v, DVector4 min, DVector4 max) => v.Min(max).Max(min);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Average(this DVector4 v1, DVector4 v2) => v1.Lerp(v2, 0.5f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Barycentric(this DVector4 v1, DVector4 v2, DVector4 v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;


        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< Vector2 > Stats(this IEnumerable< Vector2 > self)
            => self.Aggregate(Stats< Vector2 >.Default, (a, b) => new Stats< Vector2 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Average(this Stats< Vector2 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Extents(this Stats< Vector2 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Middle(this Stats< Vector2 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sum(this IEnumerable< Vector2 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Average(this IEnumerable< Vector2 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Min(this IEnumerable< Vector2 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Max(this IEnumerable< Vector2 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Extents(this IEnumerable< Vector2 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Middle(this IEnumerable< Vector2 > self) => self.Stats().Middle();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< Vector3 > Stats(this IEnumerable< Vector3 > self)
            => self.Aggregate(Stats< Vector3 >.Default, (a, b) => new Stats< Vector3 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Average(this Stats< Vector3 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Extents(this Stats< Vector3 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Middle(this Stats< Vector3 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sum(this IEnumerable< Vector3 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Average(this IEnumerable< Vector3 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Min(this IEnumerable< Vector3 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Max(this IEnumerable< Vector3 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Extents(this IEnumerable< Vector3 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Middle(this IEnumerable< Vector3 > self) => self.Stats().Middle();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< Vector4 > Stats(this IEnumerable< Vector4 > self)
            => self.Aggregate(Stats< Vector4 >.Default, (a, b) => new Stats< Vector4 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Average(this Stats< Vector4 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Extents(this Stats< Vector4 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Middle(this Stats< Vector4 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sum(this IEnumerable< Vector4 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Average(this IEnumerable< Vector4 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Min(this IEnumerable< Vector4 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Max(this IEnumerable< Vector4 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Extents(this IEnumerable< Vector4 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Middle(this IEnumerable< Vector4 > self) => self.Stats().Middle();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< DVector2 > Stats(this IEnumerable< DVector2 > self)
            => self.Aggregate(Stats< DVector2 >.Default, (a, b) => new Stats< DVector2 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Average(this Stats< DVector2 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Extents(this Stats< DVector2 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Middle(this Stats< DVector2 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sum(this IEnumerable< DVector2 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Average(this IEnumerable< DVector2 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Min(this IEnumerable< DVector2 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Max(this IEnumerable< DVector2 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Extents(this IEnumerable< DVector2 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Middle(this IEnumerable< DVector2 > self) => self.Stats().Middle();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< DVector3 > Stats(this IEnumerable< DVector3 > self)
            => self.Aggregate(Stats< DVector3 >.Default, (a, b) => new Stats< DVector3 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Average(this Stats< DVector3 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Extents(this Stats< DVector3 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Middle(this Stats< DVector3 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sum(this IEnumerable< DVector3 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Average(this IEnumerable< DVector3 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Min(this IEnumerable< DVector3 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Max(this IEnumerable< DVector3 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Extents(this IEnumerable< DVector3 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Middle(this IEnumerable< DVector3 > self) => self.Stats().Middle();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Stats< DVector4 > Stats(this IEnumerable< DVector4 > self)
            => self.Aggregate(Stats< DVector4 >.Default, (a, b) => new Stats< DVector4 >(a.Count + 1, Min(a.Min, b), Max(a.Max, b), a.Sum + b));

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Average(this Stats< DVector4 > self) => self.Sum / self.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Extents(this Stats< DVector4 > self) => self.Max - self.Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Middle(this Stats< DVector4 > self) => self.Extents() / 2 + self.Min;

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sum(this IEnumerable< DVector4 > self) => self.Stats().Sum;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Average(this IEnumerable< DVector4 > self) => self.Stats().Average();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Min(this IEnumerable< DVector4 > self) => self.Stats().Min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Max(this IEnumerable< DVector4 > self) => self.Stats().Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Extents(this IEnumerable< DVector4 > self) => self.Stats().Extents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Middle(this IEnumerable< DVector4 > self) => self.Stats().Middle();


        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector2 v1, Vector2 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector2 v1, Vector2 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector2 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector2 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Normalize(this Vector2 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 SafeNormalize(this Vector2 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector2 v1, Vector2 v2) => v1.X * v2.X + v1.Y * v2.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Min(this Vector2 v1, Vector2 v2) => new Vector2(v1.X.Min(v2.X), v1.Y.Min(v2.Y));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Max(this Vector2 v1, Vector2 v2) => new Vector2(v1.X.Max(v2.X), v1.Y.Max(v2.Y));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 SquareRoot (this Vector2 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Abs (this Vector2 v) => new Vector2(v.X.Abs(), v.Y.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Acos (this Vector2 v) => new Vector2(v.X.Acos(), v.Y.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Asin (this Vector2 v) => new Vector2(v.X.Asin(), v.Y.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Atan (this Vector2 v) => new Vector2(v.X.Atan(), v.Y.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cos (this Vector2 v) => new Vector2(v.X.Cos(), v.Y.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cosh (this Vector2 v) => new Vector2(v.X.Cosh(), v.Y.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Exp (this Vector2 v) => new Vector2(v.X.Exp(), v.Y.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Log (this Vector2 v) => new Vector2(v.X.Log(), v.Y.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Log10 (this Vector2 v) => new Vector2(v.X.Log10(), v.Y.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sin (this Vector2 v) => new Vector2(v.X.Sin(), v.Y.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sinh (this Vector2 v) => new Vector2(v.X.Sinh(), v.Y.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sqrt (this Vector2 v) => new Vector2(v.X.Sqrt(), v.Y.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Tan (this Vector2 v) => new Vector2(v.X.Tan(), v.Y.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Tanh (this Vector2 v) => new Vector2(v.X.Tanh(), v.Y.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Inverse (this Vector2 v) => new Vector2(v.X.Inverse(), v.Y.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Ceiling (this Vector2 v) => new Vector2(v.X.Ceiling(), v.Y.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Floor (this Vector2 v) => new Vector2(v.X.Floor(), v.Y.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Round (this Vector2 v) => new Vector2(v.X.Round(), v.Y.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Truncate (this Vector2 v) => new Vector2(v.X.Truncate(), v.Y.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Sqr (this Vector2 v) => new Vector2(v.X.Sqr(), v.Y.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 Cube (this Vector2 v) => new Vector2(v.X.Cube(), v.Y.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ToRadians (this Vector2 v) => new Vector2(v.X.ToRadians(), v.Y.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 ToDegrees (this Vector2 v) => new Vector2(v.X.ToDegrees(), v.Y.ToDegrees());

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector3 v1, Vector3 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector3 v1, Vector3 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector3 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector3 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Normalize(this Vector3 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 SafeNormalize(this Vector3 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector3 v1, Vector3 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Min(this Vector3 v1, Vector3 v2) => new Vector3(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Max(this Vector3 v1, Vector3 v2) => new Vector3(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 SquareRoot (this Vector3 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Abs (this Vector3 v) => new Vector3(v.X.Abs(), v.Y.Abs(), v.Z.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Acos (this Vector3 v) => new Vector3(v.X.Acos(), v.Y.Acos(), v.Z.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Asin (this Vector3 v) => new Vector3(v.X.Asin(), v.Y.Asin(), v.Z.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Atan (this Vector3 v) => new Vector3(v.X.Atan(), v.Y.Atan(), v.Z.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cos (this Vector3 v) => new Vector3(v.X.Cos(), v.Y.Cos(), v.Z.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cosh (this Vector3 v) => new Vector3(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Exp (this Vector3 v) => new Vector3(v.X.Exp(), v.Y.Exp(), v.Z.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Log (this Vector3 v) => new Vector3(v.X.Log(), v.Y.Log(), v.Z.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Log10 (this Vector3 v) => new Vector3(v.X.Log10(), v.Y.Log10(), v.Z.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sin (this Vector3 v) => new Vector3(v.X.Sin(), v.Y.Sin(), v.Z.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sinh (this Vector3 v) => new Vector3(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sqrt (this Vector3 v) => new Vector3(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Tan (this Vector3 v) => new Vector3(v.X.Tan(), v.Y.Tan(), v.Z.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Tanh (this Vector3 v) => new Vector3(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Inverse (this Vector3 v) => new Vector3(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Ceiling (this Vector3 v) => new Vector3(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Floor (this Vector3 v) => new Vector3(v.X.Floor(), v.Y.Floor(), v.Z.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Round (this Vector3 v) => new Vector3(v.X.Round(), v.Y.Round(), v.Z.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Truncate (this Vector3 v) => new Vector3(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Sqr (this Vector3 v) => new Vector3(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 Cube (this Vector3 v) => new Vector3(v.X.Cube(), v.Y.Cube(), v.Z.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ToRadians (this Vector3 v) => new Vector3(v.X.ToRadians(), v.Y.ToRadians(), v.Z.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 ToDegrees (this Vector3 v) => new Vector3(v.X.ToDegrees(), v.Y.ToDegrees(), v.Z.ToDegrees());

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float DistanceSquared(this Vector4 v1, Vector4 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Distance(this Vector4 v1, Vector4 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float LengthSquared(this Vector4 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Length(this Vector4 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Normalize(this Vector4 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 SafeNormalize(this Vector4 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(this Vector4 v1, Vector4 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Min(this Vector4 v1, Vector4 v2) => new Vector4(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z), v1.W.Min(v2.W));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Max(this Vector4 v1, Vector4 v2) => new Vector4(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z), v1.W.Max(v2.W));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 SquareRoot (this Vector4 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Abs (this Vector4 v) => new Vector4(v.X.Abs(), v.Y.Abs(), v.Z.Abs(), v.W.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Acos (this Vector4 v) => new Vector4(v.X.Acos(), v.Y.Acos(), v.Z.Acos(), v.W.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Asin (this Vector4 v) => new Vector4(v.X.Asin(), v.Y.Asin(), v.Z.Asin(), v.W.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Atan (this Vector4 v) => new Vector4(v.X.Atan(), v.Y.Atan(), v.Z.Atan(), v.W.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cos (this Vector4 v) => new Vector4(v.X.Cos(), v.Y.Cos(), v.Z.Cos(), v.W.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cosh (this Vector4 v) => new Vector4(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh(), v.W.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Exp (this Vector4 v) => new Vector4(v.X.Exp(), v.Y.Exp(), v.Z.Exp(), v.W.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Log (this Vector4 v) => new Vector4(v.X.Log(), v.Y.Log(), v.Z.Log(), v.W.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Log10 (this Vector4 v) => new Vector4(v.X.Log10(), v.Y.Log10(), v.Z.Log10(), v.W.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sin (this Vector4 v) => new Vector4(v.X.Sin(), v.Y.Sin(), v.Z.Sin(), v.W.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sinh (this Vector4 v) => new Vector4(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh(), v.W.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sqrt (this Vector4 v) => new Vector4(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt(), v.W.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Tan (this Vector4 v) => new Vector4(v.X.Tan(), v.Y.Tan(), v.Z.Tan(), v.W.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Tanh (this Vector4 v) => new Vector4(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh(), v.W.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Inverse (this Vector4 v) => new Vector4(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse(), v.W.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Ceiling (this Vector4 v) => new Vector4(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling(), v.W.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Floor (this Vector4 v) => new Vector4(v.X.Floor(), v.Y.Floor(), v.Z.Floor(), v.W.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Round (this Vector4 v) => new Vector4(v.X.Round(), v.Y.Round(), v.Z.Round(), v.W.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Truncate (this Vector4 v) => new Vector4(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate(), v.W.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Sqr (this Vector4 v) => new Vector4(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr(), v.W.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 Cube (this Vector4 v) => new Vector4(v.X.Cube(), v.Y.Cube(), v.Z.Cube(), v.W.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ToRadians (this Vector4 v) => new Vector4(v.X.ToRadians(), v.Y.ToRadians(), v.Z.ToRadians(), v.W.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 ToDegrees (this Vector4 v) => new Vector4(v.X.ToDegrees(), v.Y.ToDegrees(), v.Z.ToDegrees(), v.W.ToDegrees());

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector2 v1, DVector2 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector2 v1, DVector2 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector2 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector2 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Normalize(this DVector2 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 SafeNormalize(this DVector2 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector2 v1, DVector2 v2) => v1.X * v2.X + v1.Y * v2.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Min(this DVector2 v1, DVector2 v2) => new DVector2(v1.X.Min(v2.X), v1.Y.Min(v2.Y));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Max(this DVector2 v1, DVector2 v2) => new DVector2(v1.X.Max(v2.X), v1.Y.Max(v2.Y));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 SquareRoot (this DVector2 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Abs (this DVector2 v) => new DVector2(v.X.Abs(), v.Y.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Acos (this DVector2 v) => new DVector2(v.X.Acos(), v.Y.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Asin (this DVector2 v) => new DVector2(v.X.Asin(), v.Y.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Atan (this DVector2 v) => new DVector2(v.X.Atan(), v.Y.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cos (this DVector2 v) => new DVector2(v.X.Cos(), v.Y.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cosh (this DVector2 v) => new DVector2(v.X.Cosh(), v.Y.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Exp (this DVector2 v) => new DVector2(v.X.Exp(), v.Y.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Log (this DVector2 v) => new DVector2(v.X.Log(), v.Y.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Log10 (this DVector2 v) => new DVector2(v.X.Log10(), v.Y.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sin (this DVector2 v) => new DVector2(v.X.Sin(), v.Y.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sinh (this DVector2 v) => new DVector2(v.X.Sinh(), v.Y.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sqrt (this DVector2 v) => new DVector2(v.X.Sqrt(), v.Y.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Tan (this DVector2 v) => new DVector2(v.X.Tan(), v.Y.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Tanh (this DVector2 v) => new DVector2(v.X.Tanh(), v.Y.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Inverse (this DVector2 v) => new DVector2(v.X.Inverse(), v.Y.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Ceiling (this DVector2 v) => new DVector2(v.X.Ceiling(), v.Y.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Floor (this DVector2 v) => new DVector2(v.X.Floor(), v.Y.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Round (this DVector2 v) => new DVector2(v.X.Round(), v.Y.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Truncate (this DVector2 v) => new DVector2(v.X.Truncate(), v.Y.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Sqr (this DVector2 v) => new DVector2(v.X.Sqr(), v.Y.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 Cube (this DVector2 v) => new DVector2(v.X.Cube(), v.Y.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ToRadians (this DVector2 v) => new DVector2(v.X.ToRadians(), v.Y.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 ToDegrees (this DVector2 v) => new DVector2(v.X.ToDegrees(), v.Y.ToDegrees());

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector3 v1, DVector3 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector3 v1, DVector3 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector3 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector3 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Normalize(this DVector3 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 SafeNormalize(this DVector3 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector3 v1, DVector3 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Min(this DVector3 v1, DVector3 v2) => new DVector3(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Max(this DVector3 v1, DVector3 v2) => new DVector3(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 SquareRoot (this DVector3 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Abs (this DVector3 v) => new DVector3(v.X.Abs(), v.Y.Abs(), v.Z.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Acos (this DVector3 v) => new DVector3(v.X.Acos(), v.Y.Acos(), v.Z.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Asin (this DVector3 v) => new DVector3(v.X.Asin(), v.Y.Asin(), v.Z.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Atan (this DVector3 v) => new DVector3(v.X.Atan(), v.Y.Atan(), v.Z.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cos (this DVector3 v) => new DVector3(v.X.Cos(), v.Y.Cos(), v.Z.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cosh (this DVector3 v) => new DVector3(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Exp (this DVector3 v) => new DVector3(v.X.Exp(), v.Y.Exp(), v.Z.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Log (this DVector3 v) => new DVector3(v.X.Log(), v.Y.Log(), v.Z.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Log10 (this DVector3 v) => new DVector3(v.X.Log10(), v.Y.Log10(), v.Z.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sin (this DVector3 v) => new DVector3(v.X.Sin(), v.Y.Sin(), v.Z.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sinh (this DVector3 v) => new DVector3(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sqrt (this DVector3 v) => new DVector3(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Tan (this DVector3 v) => new DVector3(v.X.Tan(), v.Y.Tan(), v.Z.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Tanh (this DVector3 v) => new DVector3(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Inverse (this DVector3 v) => new DVector3(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Ceiling (this DVector3 v) => new DVector3(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Floor (this DVector3 v) => new DVector3(v.X.Floor(), v.Y.Floor(), v.Z.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Round (this DVector3 v) => new DVector3(v.X.Round(), v.Y.Round(), v.Z.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Truncate (this DVector3 v) => new DVector3(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Sqr (this DVector3 v) => new DVector3(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 Cube (this DVector3 v) => new DVector3(v.X.Cube(), v.Y.Cube(), v.Z.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ToRadians (this DVector3 v) => new DVector3(v.X.ToRadians(), v.Y.ToRadians(), v.Z.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 ToDegrees (this DVector3 v) => new DVector3(v.X.ToDegrees(), v.Y.ToDegrees(), v.Z.ToDegrees());

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double DistanceSquared(this DVector4 v1, DVector4 v2) => (v1 - v2).LengthSquared();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Distance(this DVector4 v1, DVector4 v2) => (v1 - v2).Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double LengthSquared(this DVector4 v) => v.SumSqrComponents();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(this DVector4 v) => v.LengthSquared().Sqrt();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Normalize(this DVector4 v) => v / v.Length();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 SafeNormalize(this DVector4 v) { var l = v.Length(); if (l != 0.0f) v = v / l; return v; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(this DVector4 v1, DVector4 v2) => v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Min(this DVector4 v1, DVector4 v2) => new DVector4(v1.X.Min(v2.X), v1.Y.Min(v2.Y), v1.Z.Min(v2.Z), v1.W.Min(v2.W));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Max(this DVector4 v1, DVector4 v2) => new DVector4(v1.X.Max(v2.X), v1.Y.Max(v2.Y), v1.Z.Max(v2.Z), v1.W.Max(v2.W));
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 SquareRoot (this DVector4 v) => v.Sqrt();

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Abs (this DVector4 v) => new DVector4(v.X.Abs(), v.Y.Abs(), v.Z.Abs(), v.W.Abs());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Acos (this DVector4 v) => new DVector4(v.X.Acos(), v.Y.Acos(), v.Z.Acos(), v.W.Acos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Asin (this DVector4 v) => new DVector4(v.X.Asin(), v.Y.Asin(), v.Z.Asin(), v.W.Asin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Atan (this DVector4 v) => new DVector4(v.X.Atan(), v.Y.Atan(), v.Z.Atan(), v.W.Atan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cos (this DVector4 v) => new DVector4(v.X.Cos(), v.Y.Cos(), v.Z.Cos(), v.W.Cos());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cosh (this DVector4 v) => new DVector4(v.X.Cosh(), v.Y.Cosh(), v.Z.Cosh(), v.W.Cosh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Exp (this DVector4 v) => new DVector4(v.X.Exp(), v.Y.Exp(), v.Z.Exp(), v.W.Exp());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Log (this DVector4 v) => new DVector4(v.X.Log(), v.Y.Log(), v.Z.Log(), v.W.Log());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Log10 (this DVector4 v) => new DVector4(v.X.Log10(), v.Y.Log10(), v.Z.Log10(), v.W.Log10());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sin (this DVector4 v) => new DVector4(v.X.Sin(), v.Y.Sin(), v.Z.Sin(), v.W.Sin());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sinh (this DVector4 v) => new DVector4(v.X.Sinh(), v.Y.Sinh(), v.Z.Sinh(), v.W.Sinh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sqrt (this DVector4 v) => new DVector4(v.X.Sqrt(), v.Y.Sqrt(), v.Z.Sqrt(), v.W.Sqrt());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Tan (this DVector4 v) => new DVector4(v.X.Tan(), v.Y.Tan(), v.Z.Tan(), v.W.Tan());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Tanh (this DVector4 v) => new DVector4(v.X.Tanh(), v.Y.Tanh(), v.Z.Tanh(), v.W.Tanh());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Inverse (this DVector4 v) => new DVector4(v.X.Inverse(), v.Y.Inverse(), v.Z.Inverse(), v.W.Inverse());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Ceiling (this DVector4 v) => new DVector4(v.X.Ceiling(), v.Y.Ceiling(), v.Z.Ceiling(), v.W.Ceiling());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Floor (this DVector4 v) => new DVector4(v.X.Floor(), v.Y.Floor(), v.Z.Floor(), v.W.Floor());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Round (this DVector4 v) => new DVector4(v.X.Round(), v.Y.Round(), v.Z.Round(), v.W.Round());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Truncate (this DVector4 v) => new DVector4(v.X.Truncate(), v.Y.Truncate(), v.Z.Truncate(), v.W.Truncate());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Sqr (this DVector4 v) => new DVector4(v.X.Sqr(), v.Y.Sqr(), v.Z.Sqr(), v.W.Sqr());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 Cube (this DVector4 v) => new DVector4(v.X.Cube(), v.Y.Cube(), v.Z.Cube(), v.W.Cube());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ToRadians (this DVector4 v) => new DVector4(v.X.ToRadians(), v.Y.ToRadians(), v.Z.ToRadians(), v.W.ToRadians());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 ToDegrees (this DVector4 v) => new DVector4(v.X.ToDegrees(), v.Y.ToDegrees(), v.Z.ToDegrees(), v.W.ToDegrees());


} }
